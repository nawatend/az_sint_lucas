{"ast":null,"code":"/*! @name mpd-parser @version 0.8.1 @license Apache-2.0 */\nimport window$1 from 'global/window';\nvar version = \"0.8.1\";\n\nvar isObject = function isObject(obj) {\n  return !!obj && typeof obj === 'object';\n};\n\nvar merge = function merge() {\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  return objects.reduce(function (result, source) {\n    Object.keys(source).forEach(function (key) {\n      if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n        result[key] = result[key].concat(source[key]);\n      } else if (isObject(result[key]) && isObject(source[key])) {\n        result[key] = merge(result[key], source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }, {});\n};\n\nvar values = function values(o) {\n  return Object.keys(o).map(function (k) {\n    return o[k];\n  });\n};\n\nvar range = function range(start, end) {\n  var result = [];\n\n  for (var i = start; i < end; i++) {\n    result.push(i);\n  }\n\n  return result;\n};\n\nvar flatten = function flatten(lists) {\n  return lists.reduce(function (x, y) {\n    return x.concat(y);\n  }, []);\n};\n\nvar from = function from(list) {\n  if (!list.length) {\n    return [];\n  }\n\n  var result = [];\n\n  for (var i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n\n  return result;\n};\n\nvar findIndexes = function findIndexes(l, key) {\n  return l.reduce(function (a, e, i) {\n    if (e[key]) {\n      a.push(i);\n    }\n\n    return a;\n  }, []);\n};\n\nvar errors = {\n  INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n  DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n  DASH_INVALID_XML: 'DASH_INVALID_XML',\n  NO_BASE_URL: 'NO_BASE_URL',\n  MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n  SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n  UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n};\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar urlToolkit = createCommonjsModule(function (module, exports) {\n  // see https://tools.ietf.org/html/rfc1808\n\n  /* jshint ignore:start */\n  (function (root) {\n    /* jshint ignore:end */\n    var URL_REGEX = /^((?:[a-zA-Z0-9+\\-.]+:)?)(\\/\\/[^\\/?#]*)?((?:[^\\/\\?#]*\\/)*.*?)??(;.*?)?(\\?.*?)?(#.*?)?$/;\n    var FIRST_SEGMENT_REGEX = /^([^\\/?#]*)(.*)$/;\n    var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n    var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/).*?(?=\\/)/g;\n    var URLToolkit = {\n      // jshint ignore:line\n      // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n      // E.g\n      // With opts.alwaysNormalize = false (default, spec compliant)\n      // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n      // With opts.alwaysNormalize = true (not spec compliant)\n      // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n      buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n        opts = opts || {}; // remove any remaining space and CRLF\n\n        baseURL = baseURL.trim();\n        relativeURL = relativeURL.trim();\n\n        if (!relativeURL) {\n          // 2a) If the embedded URL is entirely empty, it inherits the\n          // entire base URL (i.e., is set equal to the base URL)\n          // and we are done.\n          if (!opts.alwaysNormalize) {\n            return baseURL;\n          }\n\n          var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n\n          if (!basePartsForNormalise) {\n            throw new Error('Error trying to parse base URL.');\n          }\n\n          basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);\n          return URLToolkit.buildURLFromParts(basePartsForNormalise);\n        }\n\n        var relativeParts = URLToolkit.parseURL(relativeURL);\n\n        if (!relativeParts) {\n          throw new Error('Error trying to parse relative URL.');\n        }\n\n        if (relativeParts.scheme) {\n          // 2b) If the embedded URL starts with a scheme name, it is\n          // interpreted as an absolute URL and we are done.\n          if (!opts.alwaysNormalize) {\n            return relativeURL;\n          }\n\n          relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n          return URLToolkit.buildURLFromParts(relativeParts);\n        }\n\n        var baseParts = URLToolkit.parseURL(baseURL);\n\n        if (!baseParts) {\n          throw new Error('Error trying to parse base URL.');\n        }\n\n        if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n          // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n          // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n          var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n          baseParts.netLoc = pathParts[1];\n          baseParts.path = pathParts[2];\n        }\n\n        if (baseParts.netLoc && !baseParts.path) {\n          baseParts.path = '/';\n        }\n\n        var builtParts = {\n          // 2c) Otherwise, the embedded URL inherits the scheme of\n          // the base URL.\n          scheme: baseParts.scheme,\n          netLoc: relativeParts.netLoc,\n          path: null,\n          params: relativeParts.params,\n          query: relativeParts.query,\n          fragment: relativeParts.fragment\n        };\n\n        if (!relativeParts.netLoc) {\n          // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n          // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n          // (if any) of the base URL.\n          builtParts.netLoc = baseParts.netLoc; // 4) If the embedded URL path is preceded by a slash \"/\", the\n          // path is not relative and we skip to Step 7.\n\n          if (relativeParts.path[0] !== '/') {\n            if (!relativeParts.path) {\n              // 5) If the embedded URL path is empty (and not preceded by a\n              // slash), then the embedded URL inherits the base URL path\n              builtParts.path = baseParts.path; // 5a) if the embedded URL's <params> is non-empty, we skip to\n              // step 7; otherwise, it inherits the <params> of the base\n              // URL (if any) and\n\n              if (!relativeParts.params) {\n                builtParts.params = baseParts.params; // 5b) if the embedded URL's <query> is non-empty, we skip to\n                // step 7; otherwise, it inherits the <query> of the base\n                // URL (if any) and we skip to step 7.\n\n                if (!relativeParts.query) {\n                  builtParts.query = baseParts.query;\n                }\n              }\n            } else {\n              // 6) The last segment of the base URL's path (anything\n              // following the rightmost slash \"/\", or the entire path if no\n              // slash is present) is removed and the embedded URL's path is\n              // appended in its place.\n              var baseURLPath = baseParts.path;\n              var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;\n              builtParts.path = URLToolkit.normalizePath(newPath);\n            }\n          }\n        }\n\n        if (builtParts.path === null) {\n          builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;\n        }\n\n        return URLToolkit.buildURLFromParts(builtParts);\n      },\n      parseURL: function (url) {\n        var parts = URL_REGEX.exec(url);\n\n        if (!parts) {\n          return null;\n        }\n\n        return {\n          scheme: parts[1] || '',\n          netLoc: parts[2] || '',\n          path: parts[3] || '',\n          params: parts[4] || '',\n          query: parts[5] || '',\n          fragment: parts[6] || ''\n        };\n      },\n      normalizePath: function (path) {\n        // The following operations are\n        // then applied, in order, to the new path:\n        // 6a) All occurrences of \"./\", where \".\" is a complete path\n        // segment, are removed.\n        // 6b) If the path ends with \".\" as a complete path segment,\n        // that \".\" is removed.\n        path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, ''); // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n        // complete path segment not equal to \"..\", are removed.\n        // Removal of these path segments is performed iteratively,\n        // removing the leftmost matching pattern on each iteration,\n        // until no matching pattern remains.\n        // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n        // complete path segment not equal to \"..\", that\n        // \"<segment>/..\" is removed.\n\n        while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line\n\n\n        return path.split('').reverse().join('');\n      },\n      buildURLFromParts: function (parts) {\n        return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;\n      }\n    };\n    /* jshint ignore:start */\n\n    module.exports = URLToolkit;\n  })(commonjsGlobal);\n  /* jshint ignore:end */\n\n});\n\nvar resolveUrl = function resolveUrl(baseUrl, relativeUrl) {\n  // return early if we don't need to resolve\n  if (/^[a-z]+:/i.test(relativeUrl)) {\n    return relativeUrl;\n  } // if the base URL is relative then combine with the current location\n\n\n  if (!/\\/\\//i.test(baseUrl)) {\n    baseUrl = urlToolkit.buildAbsoluteURL(window$1.location.href, baseUrl);\n  }\n\n  return urlToolkit.buildAbsoluteURL(baseUrl, relativeUrl);\n};\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */\n\n/**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls,\n *   follows  RFC 2616, Clause 14.35.1\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */\n\n\nvar urlTypeToSegment = function urlTypeToSegment(_ref) {\n  var _ref$baseUrl = _ref.baseUrl,\n      baseUrl = _ref$baseUrl === void 0 ? '' : _ref$baseUrl,\n      _ref$source = _ref.source,\n      source = _ref$source === void 0 ? '' : _ref$source,\n      _ref$range = _ref.range,\n      range = _ref$range === void 0 ? '' : _ref$range,\n      _ref$indexRange = _ref.indexRange,\n      indexRange = _ref$indexRange === void 0 ? '' : _ref$indexRange;\n  var segment = {\n    uri: source,\n    resolvedUri: resolveUrl(baseUrl || '', source)\n  };\n\n  if (range || indexRange) {\n    var rangeStr = range ? range : indexRange;\n    var ranges = rangeStr.split('-');\n    var startRange = parseInt(ranges[0], 10);\n    var endRange = parseInt(ranges[1], 10); // byterange should be inclusive according to\n    // RFC 2616, Clause 14.35.1\n\n    segment.byterange = {\n      length: endRange - startRange + 1,\n      offset: startRange\n    };\n  }\n\n  return segment;\n};\n\nvar byteRangeToString = function byteRangeToString(byterange) {\n  // `endRange` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  var endRange = byterange.offset + byterange.length - 1;\n  return byterange.offset + \"-\" + endRange;\n};\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */\n\n\nvar segmentRange = {\n  /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  static: function _static(attributes) {\n    var duration = attributes.duration,\n        _attributes$timescale = attributes.timescale,\n        timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n        sourceDuration = attributes.sourceDuration;\n    return {\n      start: 0,\n      end: Math.ceil(sourceDuration / (duration / timescale))\n    };\n  },\n\n  /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  dynamic: function dynamic(attributes) {\n    var NOW = attributes.NOW,\n        clientOffset = attributes.clientOffset,\n        availabilityStartTime = attributes.availabilityStartTime,\n        _attributes$timescale2 = attributes.timescale,\n        timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,\n        duration = attributes.duration,\n        _attributes$start = attributes.start,\n        start = _attributes$start === void 0 ? 0 : _attributes$start,\n        _attributes$minimumUp = attributes.minimumUpdatePeriod,\n        minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp,\n        _attributes$timeShift = attributes.timeShiftBufferDepth,\n        timeShiftBufferDepth = _attributes$timeShift === void 0 ? Infinity : _attributes$timeShift;\n    var now = (NOW + clientOffset) / 1000;\n    var periodStartWC = availabilityStartTime + start;\n    var periodEndWC = now + minimumUpdatePeriod;\n    var periodDuration = periodEndWC - periodStartWC;\n    var segmentCount = Math.ceil(periodDuration * timescale / duration);\n    var availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n    var availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n    return {\n      start: Math.max(0, availableStart),\n      end: Math.min(segmentCount, availableEnd)\n    };\n  }\n};\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */\n\nvar toSegments = function toSegments(attributes) {\n  return function (number, index) {\n    var duration = attributes.duration,\n        _attributes$timescale3 = attributes.timescale,\n        timescale = _attributes$timescale3 === void 0 ? 1 : _attributes$timescale3,\n        periodIndex = attributes.periodIndex,\n        _attributes$startNumb = attributes.startNumber,\n        startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb;\n    return {\n      number: startNumber + number,\n      duration: duration / timescale,\n      timeline: periodIndex,\n      time: index * duration\n    };\n  };\n};\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nvar parseByDuration = function parseByDuration(attributes) {\n  var _attributes$type = attributes.type,\n      type = _attributes$type === void 0 ? 'static' : _attributes$type,\n      duration = attributes.duration,\n      _attributes$timescale4 = attributes.timescale,\n      timescale = _attributes$timescale4 === void 0 ? 1 : _attributes$timescale4,\n      sourceDuration = attributes.sourceDuration;\n\n  var _segmentRange$type = segmentRange[type](attributes),\n      start = _segmentRange$type.start,\n      end = _segmentRange$type.end;\n\n  var segments = range(start, end).map(toSegments(attributes));\n\n  if (type === 'static') {\n    var index = segments.length - 1; // final segment may be less than full segment duration\n\n    segments[index].duration = sourceDuration - duration / timescale * index;\n  }\n\n  return segments;\n};\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */\n\n\nvar segmentsFromBase = function segmentsFromBase(attributes) {\n  var baseUrl = attributes.baseUrl,\n      _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ,\n      sourceDuration = attributes.sourceDuration,\n      _attributes$timescale = attributes.timescale,\n      timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n      _attributes$indexRang = attributes.indexRange,\n      indexRange = _attributes$indexRang === void 0 ? '' : _attributes$indexRang,\n      duration = attributes.duration; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n  if (!baseUrl) {\n    throw new Error(errors.NO_BASE_URL);\n  }\n\n  var initSegment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  var segment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: baseUrl,\n    indexRange: indexRange\n  });\n  segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n  // (since SegmentBase is only for one total segment)\n\n  if (duration) {\n    var segmentTimeInfo = parseByDuration(attributes);\n\n    if (segmentTimeInfo.length) {\n      segment.duration = segmentTimeInfo[0].duration;\n      segment.timeline = segmentTimeInfo[0].timeline;\n    }\n  } else if (sourceDuration) {\n    segment.duration = sourceDuration / timescale;\n    segment.timeline = 0;\n  } // This is used for mediaSequence\n\n\n  segment.number = 0;\n  return [segment];\n};\n/**\n * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n * according to the sidx information given.\n *\n * playlist.sidx has metadadata about the sidx where-as the sidx param\n * is the parsed sidx box itself.\n *\n * @param {Object} playlist the playlist to update the sidx information for\n * @param {Object} sidx the parsed sidx box\n * @return {Object} the playlist object with the updated sidx information\n */\n\n\nvar addSegmentsToPlaylist = function addSegmentsToPlaylist(playlist, sidx, baseUrl) {\n  // Retain init segment information\n  var initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial master manifest parsing\n\n  var sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n  var timeline = playlist.timeline || 0;\n  var sidxByteRange = playlist.sidx.byterange;\n  var sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n  var timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n  var mediaReferences = sidx.references.filter(function (r) {\n    return r.referenceType !== 1;\n  });\n  var segments = []; // firstOffset is the offset from the end of the sidx box\n\n  var startIndex = sidxEnd + sidx.firstOffset;\n\n  for (var i = 0; i < mediaReferences.length; i++) {\n    var reference = sidx.references[i]; // size of the referenced (sub)segment\n\n    var size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n    // this will be converted to seconds when generating segments\n\n    var duration = reference.subsegmentDuration; // should be an inclusive range\n\n    var endIndex = startIndex + size - 1;\n    var indexRange = startIndex + \"-\" + endIndex;\n    var attributes = {\n      baseUrl: baseUrl,\n      timescale: timescale,\n      timeline: timeline,\n      // this is used in parseByDuration\n      periodIndex: timeline,\n      duration: duration,\n      sourceDuration: sourceDuration,\n      indexRange: indexRange\n    };\n    var segment = segmentsFromBase(attributes)[0];\n\n    if (initSegment) {\n      segment.map = initSegment;\n    }\n\n    segments.push(segment);\n    startIndex += size;\n  }\n\n  playlist.segments = segments;\n  return playlist;\n};\n\nvar mergeDiscontiguousPlaylists = function mergeDiscontiguousPlaylists(playlists) {\n  var mergedPlaylists = values(playlists.reduce(function (acc, playlist) {\n    // assuming playlist IDs are the same across periods\n    // TODO: handle multiperiod where representation sets are not the same\n    // across periods\n    var name = playlist.attributes.id + (playlist.attributes.lang || ''); // Periods after first\n\n    if (acc[name]) {\n      var _acc$name$segments; // first segment of subsequent periods signal a discontinuity\n\n\n      if (playlist.segments[0]) {\n        playlist.segments[0].discontinuity = true;\n      }\n\n      (_acc$name$segments = acc[name].segments).push.apply(_acc$name$segments, playlist.segments); // bubble up contentProtection, this assumes all DRM content\n      // has the same contentProtection\n\n\n      if (playlist.attributes.contentProtection) {\n        acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n      }\n    } else {\n      // first Period\n      acc[name] = playlist;\n    }\n\n    return acc;\n  }, {}));\n  return mergedPlaylists.map(function (playlist) {\n    playlist.discontinuityStarts = findIndexes(playlist.segments, 'discontinuity');\n    return playlist;\n  });\n};\n\nvar addSegmentInfoFromSidx = function addSegmentInfoFromSidx(playlists, sidxMapping) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  if (!Object.keys(sidxMapping).length) {\n    return playlists;\n  }\n\n  for (var i in playlists) {\n    var playlist = playlists[i];\n\n    if (!playlist.sidx) {\n      continue;\n    }\n\n    var sidxKey = playlist.sidx.uri + '-' + byteRangeToString(playlist.sidx.byterange);\n    var sidxMatch = sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n\n    if (playlist.sidx && sidxMatch) {\n      addSegmentsToPlaylist(playlist, sidxMatch, playlist.sidx.resolvedUri);\n    }\n  }\n\n  return playlists;\n};\n\nvar formatAudioPlaylist = function formatAudioPlaylist(_ref) {\n  var _attributes;\n\n  var attributes = _ref.attributes,\n      segments = _ref.segments,\n      sidx = _ref.sidx;\n  var playlist = {\n    attributes: (_attributes = {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      CODECS: attributes.codecs\n    }, _attributes['PROGRAM-ID'] = 1, _attributes),\n    uri: '',\n    endList: (attributes.type || 'static') === 'static',\n    timeline: attributes.periodIndex,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    segments: segments,\n    mediaSequence: segments.length ? segments[0].number : 1\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  return playlist;\n};\n\nvar formatVttPlaylist = function formatVttPlaylist(_ref2) {\n  var _attributes2;\n\n  var attributes = _ref2.attributes,\n      segments = _ref2.segments;\n\n  if (typeof segments === 'undefined') {\n    // vtt tracks may use single file in BaseURL\n    segments = [{\n      uri: attributes.baseUrl,\n      timeline: attributes.periodIndex,\n      resolvedUri: attributes.baseUrl || '',\n      duration: attributes.sourceDuration,\n      number: 0\n    }]; // targetDuration should be the same duration as the only segment\n\n    attributes.duration = attributes.sourceDuration;\n  }\n\n  return {\n    attributes: (_attributes2 = {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth\n    }, _attributes2['PROGRAM-ID'] = 1, _attributes2),\n    uri: '',\n    endList: (attributes.type || 'static') === 'static',\n    timeline: attributes.periodIndex,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    segments: segments,\n    mediaSequence: segments.length ? segments[0].number : 1\n  };\n};\n\nvar organizeAudioPlaylists = function organizeAudioPlaylists(playlists, sidxMapping) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  var mainPlaylist;\n  var formattedPlaylists = playlists.reduce(function (a, playlist) {\n    var role = playlist.attributes.role && playlist.attributes.role.value || '';\n    var language = playlist.attributes.lang || '';\n    var label = 'main';\n\n    if (language) {\n      var roleLabel = role ? \" (\" + role + \")\" : '';\n      label = \"\" + playlist.attributes.lang + roleLabel;\n    } // skip if we already have the highest quality audio for a language\n\n\n    if (a[label] && a[label].playlists[0].attributes.BANDWIDTH > playlist.attributes.bandwidth) {\n      return a;\n    }\n\n    a[label] = {\n      language: language,\n      autoselect: true,\n      default: role === 'main',\n      playlists: addSegmentInfoFromSidx([formatAudioPlaylist(playlist)], sidxMapping),\n      uri: ''\n    };\n\n    if (typeof mainPlaylist === 'undefined' && role === 'main') {\n      mainPlaylist = playlist;\n      mainPlaylist.default = true;\n    }\n\n    return a;\n  }, {}); // if no playlists have role \"main\", mark the first as main\n\n  if (!mainPlaylist) {\n    var firstLabel = Object.keys(formattedPlaylists)[0];\n    formattedPlaylists[firstLabel].default = true;\n  }\n\n  return formattedPlaylists;\n};\n\nvar organizeVttPlaylists = function organizeVttPlaylists(playlists, sidxMapping) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  return playlists.reduce(function (a, playlist) {\n    var label = playlist.attributes.lang || 'text'; // skip if we already have subtitles\n\n    if (a[label]) {\n      return a;\n    }\n\n    a[label] = {\n      language: label,\n      default: false,\n      autoselect: false,\n      playlists: addSegmentInfoFromSidx([formatVttPlaylist(playlist)], sidxMapping),\n      uri: ''\n    };\n    return a;\n  }, {});\n};\n\nvar formatVideoPlaylist = function formatVideoPlaylist(_ref3) {\n  var _attributes3;\n\n  var attributes = _ref3.attributes,\n      segments = _ref3.segments,\n      sidx = _ref3.sidx;\n  var playlist = {\n    attributes: (_attributes3 = {\n      NAME: attributes.id,\n      AUDIO: 'audio',\n      SUBTITLES: 'subs',\n      RESOLUTION: {\n        width: attributes.width,\n        height: attributes.height\n      },\n      CODECS: attributes.codecs,\n      BANDWIDTH: attributes.bandwidth\n    }, _attributes3['PROGRAM-ID'] = 1, _attributes3),\n    uri: '',\n    endList: (attributes.type || 'static') === 'static',\n    timeline: attributes.periodIndex,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    segments: segments,\n    mediaSequence: segments.length ? segments[0].number : 1\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  return playlist;\n};\n\nvar toM3u8 = function toM3u8(dashPlaylists, sidxMapping) {\n  var _mediaGroups;\n\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  if (!dashPlaylists.length) {\n    return {};\n  } // grab all master attributes\n\n\n  var _dashPlaylists$0$attr = dashPlaylists[0].attributes,\n      duration = _dashPlaylists$0$attr.sourceDuration,\n      _dashPlaylists$0$attr2 = _dashPlaylists$0$attr.minimumUpdatePeriod,\n      minimumUpdatePeriod = _dashPlaylists$0$attr2 === void 0 ? 0 : _dashPlaylists$0$attr2;\n\n  var videoOnly = function videoOnly(_ref4) {\n    var attributes = _ref4.attributes;\n    return attributes.mimeType === 'video/mp4' || attributes.contentType === 'video';\n  };\n\n  var audioOnly = function audioOnly(_ref5) {\n    var attributes = _ref5.attributes;\n    return attributes.mimeType === 'audio/mp4' || attributes.contentType === 'audio';\n  };\n\n  var vttOnly = function vttOnly(_ref6) {\n    var attributes = _ref6.attributes;\n    return attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n  };\n\n  var videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n  var audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n  var vttPlaylists = dashPlaylists.filter(vttOnly);\n  var master = {\n    allowCache: true,\n    discontinuityStarts: [],\n    segments: [],\n    endList: true,\n    mediaGroups: (_mediaGroups = {\n      AUDIO: {},\n      VIDEO: {}\n    }, _mediaGroups['CLOSED-CAPTIONS'] = {}, _mediaGroups.SUBTITLES = {}, _mediaGroups),\n    uri: '',\n    duration: duration,\n    playlists: addSegmentInfoFromSidx(videoPlaylists, sidxMapping),\n    minimumUpdatePeriod: minimumUpdatePeriod * 1000\n  };\n\n  if (audioPlaylists.length) {\n    master.mediaGroups.AUDIO.audio = organizeAudioPlaylists(audioPlaylists, sidxMapping);\n  }\n\n  if (vttPlaylists.length) {\n    master.mediaGroups.SUBTITLES.subs = organizeVttPlaylists(vttPlaylists, sidxMapping);\n  }\n\n  return master;\n};\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */\n\n\nvar getLiveRValue = function getLiveRValue(attributes, time, duration) {\n  var NOW = attributes.NOW,\n      clientOffset = attributes.clientOffset,\n      availabilityStartTime = attributes.availabilityStartTime,\n      _attributes$timescale = attributes.timescale,\n      timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n      _attributes$start = attributes.start,\n      start = _attributes$start === void 0 ? 0 : _attributes$start,\n      _attributes$minimumUp = attributes.minimumUpdatePeriod,\n      minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp;\n  var now = (NOW + clientOffset) / 1000;\n  var periodStartWC = availabilityStartTime + start;\n  var periodEndWC = now + minimumUpdatePeriod;\n  var periodDuration = periodEndWC - periodStartWC;\n  return Math.ceil((periodDuration * timescale - time) / duration);\n};\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nvar parseByTimeline = function parseByTimeline(attributes, segmentTimeline) {\n  var _attributes$type = attributes.type,\n      type = _attributes$type === void 0 ? 'static' : _attributes$type,\n      _attributes$minimumUp2 = attributes.minimumUpdatePeriod,\n      minimumUpdatePeriod = _attributes$minimumUp2 === void 0 ? 0 : _attributes$minimumUp2,\n      _attributes$media = attributes.media,\n      media = _attributes$media === void 0 ? '' : _attributes$media,\n      sourceDuration = attributes.sourceDuration,\n      _attributes$timescale2 = attributes.timescale,\n      timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,\n      _attributes$startNumb = attributes.startNumber,\n      startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb,\n      timeline = attributes.periodIndex;\n  var segments = [];\n  var time = -1;\n\n  for (var sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n    var S = segmentTimeline[sIndex];\n    var duration = S.d;\n    var repeat = S.r || 0;\n    var segmentTime = S.t || 0;\n\n    if (time < 0) {\n      // first segment\n      time = segmentTime;\n    }\n\n    if (segmentTime && segmentTime > time) {\n      // discontinuity\n      // TODO: How to handle this type of discontinuity\n      // timeline++ here would treat it like HLS discontuity and content would\n      // get appended without gap\n      // E.G.\n      //  <S t=\"0\" d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S t=\"5\" d=\"1\" />\n      // would have $Time$ values of [0, 1, 2, 5]\n      // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n      // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n      // does the value of sourceDuration consider this when calculating arbitrary\n      // negative @r repeat value?\n      // E.G. Same elements as above with this added at the end\n      //  <S d=\"1\" r=\"-1\" />\n      //  with a sourceDuration of 10\n      // Would the 2 gaps be included in the time duration calculations resulting in\n      // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n      // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n      time = segmentTime;\n    }\n\n    var count = void 0;\n\n    if (repeat < 0) {\n      var nextS = sIndex + 1;\n\n      if (nextS === segmentTimeline.length) {\n        // last segment\n        if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n          count = getLiveRValue(attributes, time, duration);\n        } else {\n          // TODO: This may be incorrect depending on conclusion of TODO above\n          count = (sourceDuration * timescale - time) / duration;\n        }\n      } else {\n        count = (segmentTimeline[nextS].t - time) / duration;\n      }\n    } else {\n      count = repeat + 1;\n    }\n\n    var end = startNumber + segments.length + count;\n    var number = startNumber + segments.length;\n\n    while (number < end) {\n      segments.push({\n        number: number,\n        duration: duration / timescale,\n        time: time,\n        timeline: timeline\n      });\n      time += duration;\n      number++;\n    }\n  }\n\n  return segments;\n};\n\nvar identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */\n\n/**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */\n\nvar identifierReplacement = function identifierReplacement(values) {\n  return function (match, identifier, format, width) {\n    if (match === '$$') {\n      // escape sequence\n      return '$';\n    }\n\n    if (typeof values[identifier] === 'undefined') {\n      return match;\n    }\n\n    var value = '' + values[identifier];\n\n    if (identifier === 'RepresentationID') {\n      // Format tag shall not be present with RepresentationID\n      return value;\n    }\n\n    if (!format) {\n      width = 1;\n    } else {\n      width = parseInt(width, 10);\n    }\n\n    if (value.length >= width) {\n      return value;\n    }\n\n    return \"\" + new Array(width - value.length + 1).join('0') + value;\n  };\n};\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */\n\n\nvar constructTemplateUrl = function constructTemplateUrl(url, values) {\n  return url.replace(identifierPattern, identifierReplacement(values));\n};\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nvar parseTemplateInfo = function parseTemplateInfo(attributes, segmentTimeline) {\n  if (!attributes.duration && !segmentTimeline) {\n    // if neither @duration or SegmentTimeline are present, then there shall be exactly\n    // one media segment\n    return [{\n      number: attributes.startNumber || 1,\n      duration: attributes.sourceDuration,\n      time: 0,\n      timeline: attributes.periodIndex\n    }];\n  }\n\n  if (attributes.duration) {\n    return parseByDuration(attributes);\n  }\n\n  return parseByTimeline(attributes, segmentTimeline);\n};\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */\n\n\nvar segmentsFromTemplate = function segmentsFromTemplate(attributes, segmentTimeline) {\n  var templateValues = {\n    RepresentationID: attributes.id,\n    Bandwidth: attributes.bandwidth || 0\n  };\n  var _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {\n    sourceURL: '',\n    range: ''\n  } : _attributes$initializ;\n  var mapSegment = urlTypeToSegment({\n    baseUrl: attributes.baseUrl,\n    source: constructTemplateUrl(initialization.sourceURL, templateValues),\n    range: initialization.range\n  });\n  var segments = parseTemplateInfo(attributes, segmentTimeline);\n  return segments.map(function (segment) {\n    templateValues.Number = segment.number;\n    templateValues.Time = segment.time;\n    var uri = constructTemplateUrl(attributes.media || '', templateValues);\n    return {\n      uri: uri,\n      timeline: segment.timeline,\n      duration: segment.duration,\n      resolvedUri: resolveUrl(attributes.baseUrl || '', uri),\n      map: mapSegment,\n      number: segment.number\n    };\n  });\n};\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */\n\n\nvar SegmentURLToSegmentObject = function SegmentURLToSegmentObject(attributes, segmentUrl) {\n  var baseUrl = attributes.baseUrl,\n      _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ;\n  var initSegment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  var segment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: segmentUrl.media,\n    range: segmentUrl.mediaRange\n  });\n  segment.map = initSegment;\n  return segment;\n};\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */\n\n\nvar segmentsFromList = function segmentsFromList(attributes, segmentTimeline) {\n  var duration = attributes.duration,\n      _attributes$segmentUr = attributes.segmentUrls,\n      segmentUrls = _attributes$segmentUr === void 0 ? [] : _attributes$segmentUr; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n  // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n  if (!duration && !segmentTimeline || duration && segmentTimeline) {\n    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n  }\n\n  var segmentUrlMap = segmentUrls.map(function (segmentUrlObject) {\n    return SegmentURLToSegmentObject(attributes, segmentUrlObject);\n  });\n  var segmentTimeInfo;\n\n  if (duration) {\n    segmentTimeInfo = parseByDuration(attributes);\n  }\n\n  if (segmentTimeline) {\n    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n  }\n\n  var segments = segmentTimeInfo.map(function (segmentTime, index) {\n    if (segmentUrlMap[index]) {\n      var segment = segmentUrlMap[index];\n      segment.timeline = segmentTime.timeline;\n      segment.duration = segmentTime.duration;\n      segment.number = segmentTime.number;\n      return segment;\n    } // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n\n  }).filter(function (segment) {\n    return segment;\n  });\n  return segments;\n};\n\nvar generateSegments = function generateSegments(_ref) {\n  var attributes = _ref.attributes,\n      segmentInfo = _ref.segmentInfo;\n  var segmentAttributes;\n  var segmentsFn;\n\n  if (segmentInfo.template) {\n    segmentsFn = segmentsFromTemplate;\n    segmentAttributes = merge(attributes, segmentInfo.template);\n  } else if (segmentInfo.base) {\n    segmentsFn = segmentsFromBase;\n    segmentAttributes = merge(attributes, segmentInfo.base);\n  } else if (segmentInfo.list) {\n    segmentsFn = segmentsFromList;\n    segmentAttributes = merge(attributes, segmentInfo.list);\n  }\n\n  var segmentsInfo = {\n    attributes: attributes\n  };\n\n  if (!segmentsFn) {\n    return segmentsInfo;\n  }\n\n  var segments = segmentsFn(segmentAttributes, segmentInfo.timeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n  // must be in seconds. Since we've generated the segment list, we no longer need\n  // @duration to be in @timescale units, so we can convert it here.\n\n  if (segmentAttributes.duration) {\n    var _segmentAttributes = segmentAttributes,\n        duration = _segmentAttributes.duration,\n        _segmentAttributes$ti = _segmentAttributes.timescale,\n        timescale = _segmentAttributes$ti === void 0 ? 1 : _segmentAttributes$ti;\n    segmentAttributes.duration = duration / timescale;\n  } else if (segments.length) {\n    // if there is no @duration attribute, use the largest segment duration as\n    // as target duration\n    segmentAttributes.duration = segments.reduce(function (max, segment) {\n      return Math.max(max, Math.ceil(segment.duration));\n    }, 0);\n  } else {\n    segmentAttributes.duration = 0;\n  }\n\n  segmentsInfo.attributes = segmentAttributes;\n  segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n  if (segmentInfo.base && segmentAttributes.indexRange) {\n    segmentsInfo.sidx = segments[0];\n    segmentsInfo.segments = [];\n  }\n\n  return segmentsInfo;\n};\n\nvar toPlaylists = function toPlaylists(representations) {\n  return representations.map(generateSegments);\n};\n\nvar findChildren = function findChildren(element, name) {\n  return from(element.childNodes).filter(function (_ref) {\n    var tagName = _ref.tagName;\n    return tagName === name;\n  });\n};\n\nvar getContent = function getContent(element) {\n  return element.textContent.trim();\n};\n\nvar parseDuration = function parseDuration(str) {\n  var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n  var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n  var SECONDS_IN_DAY = 24 * 60 * 60;\n  var SECONDS_IN_HOUR = 60 * 60;\n  var SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n  var durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n  var match = durationRegex.exec(str);\n\n  if (!match) {\n    return 0;\n  }\n\n  var _match$slice = match.slice(1),\n      year = _match$slice[0],\n      month = _match$slice[1],\n      day = _match$slice[2],\n      hour = _match$slice[3],\n      minute = _match$slice[4],\n      second = _match$slice[5];\n\n  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\n\nvar parseDate = function parseDate(str) {\n  // Date format without timezone according to ISO 8601\n  // YYY-MM-DDThh:mm:ss.ssssss\n  var dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n  // expressed by ending with 'Z'\n\n  if (dateRegex.test(str)) {\n    str += 'Z';\n  }\n\n  return Date.parse(str);\n};\n\nvar parsers = {\n  /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  mediaPresentationDuration: function mediaPresentationDuration(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */\n  availabilityStartTime: function availabilityStartTime(value) {\n    return parseDate(value) / 1000;\n  },\n\n  /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  minimumUpdatePeriod: function minimumUpdatePeriod(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  timeShiftBufferDepth: function timeShiftBufferDepth(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  start: function start(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */\n  width: function width(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */\n  height: function height(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */\n  bandwidth: function bandwidth(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  startNumber: function startNumber(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The aprsed timescale\n   */\n  timescale: function timescale(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  duration: function duration(value) {\n    var parsedValue = parseInt(value, 10);\n\n    if (isNaN(parsedValue)) {\n      return parseDuration(value);\n    }\n\n    return parsedValue;\n  },\n\n  /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  d: function d(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */\n  t: function t(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  r: function r(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */\n  DEFAULT: function DEFAULT(value) {\n    return value;\n  }\n};\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */\n\nvar parseAttributes = function parseAttributes(el) {\n  if (!(el && el.attributes)) {\n    return {};\n  }\n\n  return from(el.attributes).reduce(function (a, e) {\n    var parseFn = parsers[e.name] || parsers.DEFAULT;\n    a[e.name] = parseFn(e.value);\n    return a;\n  }, {});\n};\n\nfunction decodeB64ToUint8Array(b64Text) {\n  var decodedString = window$1.atob(b64Text);\n  var array = new Uint8Array(decodedString.length);\n\n  for (var i = 0; i < decodedString.length; i++) {\n    array[i] = decodedString.charCodeAt(i);\n  }\n\n  return array;\n}\n\nvar keySystemsMap = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\n};\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {string[]} referenceUrls\n *        List of reference urls to resolve to\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {string[]}\n *         List of resolved urls\n */\n\nvar buildBaseUrls = function buildBaseUrls(referenceUrls, baseUrlElements) {\n  if (!baseUrlElements.length) {\n    return referenceUrls;\n  }\n\n  return flatten(referenceUrls.map(function (reference) {\n    return baseUrlElements.map(function (baseUrlElement) {\n      return resolveUrl(reference, getContent(baseUrlElement));\n    });\n  }));\n};\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} timeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */\n\n/**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */\n\n\nvar getSegmentInformation = function getSegmentInformation(adaptationSet) {\n  var segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n  var segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n  var segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(function (s) {\n    return merge({\n      tag: 'SegmentURL'\n    }, parseAttributes(s));\n  });\n  var segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n  var segmentTimelineParentNode = segmentList || segmentTemplate;\n  var segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n  var segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n  var segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n  // @initialization and an <Initialization> node.  @initialization can be templated,\n  // while the node can have a url and range specified.  If the <SegmentTemplate> has\n  // both @initialization and an <Initialization> subelement we opt to override with\n  // the node, as this interaction is not defined in the spec.\n\n  var template = segmentTemplate && parseAttributes(segmentTemplate);\n\n  if (template && segmentInitialization) {\n    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n  } else if (template && template.initialization) {\n    // If it is @initialization we convert it to an object since this is the format that\n    // later functions will rely on for the initialization segment.  This is only valid\n    // for <SegmentTemplate>\n    template.initialization = {\n      sourceURL: template.initialization\n    };\n  }\n\n  var segmentInfo = {\n    template: template,\n    timeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(function (s) {\n      return parseAttributes(s);\n    }),\n    list: segmentList && merge(parseAttributes(segmentList), {\n      segmentUrls: segmentUrls,\n      initialization: parseAttributes(segmentInitialization)\n    }),\n    base: segmentBase && merge(parseAttributes(segmentBase), {\n      initialization: parseAttributes(segmentInitialization)\n    })\n  };\n  Object.keys(segmentInfo).forEach(function (key) {\n    if (!segmentInfo[key]) {\n      delete segmentInfo[key];\n    }\n  });\n  return segmentInfo;\n};\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */\n\n/**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {string[]} adaptationSetBaseUrls\n *        Contains list of resolved base urls inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */\n\n\nvar inheritBaseUrls = function inheritBaseUrls(adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) {\n  return function (representation) {\n    var repBaseUrlElements = findChildren(representation, 'BaseURL');\n    var repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n    var attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n    var representationSegmentInfo = getSegmentInformation(representation);\n    return repBaseUrls.map(function (baseUrl) {\n      return {\n        segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n        attributes: merge(attributes, {\n          baseUrl: baseUrl\n        })\n      };\n    });\n  };\n};\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */\n\n\nvar generateKeySystemInformation = function generateKeySystemInformation(contentProtectionNodes) {\n  return contentProtectionNodes.reduce(function (acc, node) {\n    var attributes = parseAttributes(node);\n    var keySystem = keySystemsMap[attributes.schemeIdUri];\n\n    if (keySystem) {\n      acc[keySystem] = {\n        attributes: attributes\n      };\n      var psshNode = findChildren(node, 'cenc:pssh')[0];\n\n      if (psshNode) {\n        var pssh = getContent(psshNode);\n        var psshBuffer = pssh && decodeB64ToUint8Array(pssh);\n        acc[keySystem].pssh = psshBuffer;\n      }\n    }\n\n    return acc;\n  }, {});\n};\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {string[]} periodBaseUrls\n *        Contains list of resolved base urls inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */\n\n\nvar toRepresentations = function toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo) {\n  return function (adaptationSet) {\n    var adaptationSetAttributes = parseAttributes(adaptationSet);\n    var adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n    var role = findChildren(adaptationSet, 'Role')[0];\n    var roleAttributes = {\n      role: parseAttributes(role)\n    };\n    var attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n    var contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n\n    if (Object.keys(contentProtection).length) {\n      attrs = merge(attrs, {\n        contentProtection: contentProtection\n      });\n    }\n\n    var segmentInfo = getSegmentInformation(adaptationSet);\n    var representations = findChildren(adaptationSet, 'Representation');\n    var adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n    return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n  };\n};\n/**\n * Maps an Period node to a list of Representation inforamtion objects for all\n * AdaptationSet nodes contained within the Period\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {Node} period\n *        Period node from the mpd\n * @param {number} periodIndex\n *        Index of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n * @param {string[]} mpdBaseUrls\n *        Contains list of resolved base urls inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */\n\n\nvar toAdaptationSets = function toAdaptationSets(mpdAttributes, mpdBaseUrls) {\n  return function (period, index) {\n    var periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period, 'BaseURL'));\n    var periodAtt = parseAttributes(period);\n    var parsedPeriodId = parseInt(periodAtt.id, 10); // fallback to mapping index if Period@id is not a number\n\n    var periodIndex = window$1.isNaN(parsedPeriodId) ? index : parsedPeriodId;\n    var periodAttributes = merge(mpdAttributes, {\n      periodIndex: periodIndex\n    });\n    var adaptationSets = findChildren(period, 'AdaptationSet');\n    var periodSegmentInfo = getSegmentInformation(period);\n    return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n  };\n};\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */\n\n\nvar inheritAttributes = function inheritAttributes(mpd, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$manifestUri = _options.manifestUri,\n      manifestUri = _options$manifestUri === void 0 ? '' : _options$manifestUri,\n      _options$NOW = _options.NOW,\n      NOW = _options$NOW === void 0 ? Date.now() : _options$NOW,\n      _options$clientOffset = _options.clientOffset,\n      clientOffset = _options$clientOffset === void 0 ? 0 : _options$clientOffset;\n  var periods = findChildren(mpd, 'Period');\n\n  if (!periods.length) {\n    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n  }\n\n  var mpdAttributes = parseAttributes(mpd);\n  var mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, 'BaseURL'));\n  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n  mpdAttributes.NOW = NOW;\n  mpdAttributes.clientOffset = clientOffset;\n  return flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)));\n};\n\nvar stringToMpdXml = function stringToMpdXml(manifestString) {\n  if (manifestString === '') {\n    throw new Error(errors.DASH_EMPTY_MANIFEST);\n  }\n\n  var parser = new window$1.DOMParser();\n  var xml = parser.parseFromString(manifestString, 'application/xml');\n  var mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n\n  if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n    throw new Error(errors.DASH_INVALID_XML);\n  }\n\n  return mpd;\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\n\nvar parseUTCTimingScheme = function parseUTCTimingScheme(mpd) {\n  var UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n\n  if (!UTCTimingNode) {\n    return null;\n  }\n\n  var attributes = parseAttributes(UTCTimingNode);\n\n  switch (attributes.schemeIdUri) {\n    case 'urn:mpeg:dash:utc:http-head:2014':\n    case 'urn:mpeg:dash:utc:http-head:2012':\n      attributes.method = 'HEAD';\n      break;\n\n    case 'urn:mpeg:dash:utc:http-xsdate:2014':\n    case 'urn:mpeg:dash:utc:http-iso:2014':\n    case 'urn:mpeg:dash:utc:http-xsdate:2012':\n    case 'urn:mpeg:dash:utc:http-iso:2012':\n      attributes.method = 'GET';\n      break;\n\n    case 'urn:mpeg:dash:utc:direct:2014':\n    case 'urn:mpeg:dash:utc:direct:2012':\n      attributes.method = 'DIRECT';\n      attributes.value = Date.parse(attributes.value);\n      break;\n\n    case 'urn:mpeg:dash:utc:http-ntp:2014':\n    case 'urn:mpeg:dash:utc:ntp:2014':\n    case 'urn:mpeg:dash:utc:sntp:2014':\n    default:\n      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n  }\n\n  return attributes;\n};\n\nvar VERSION = version;\n\nvar parse = function parse(manifestString, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return toM3u8(toPlaylists(inheritAttributes(stringToMpdXml(manifestString), options)), options.sidxMapping);\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\n\nvar parseUTCTiming = function parseUTCTiming(manifestString) {\n  return parseUTCTimingScheme(stringToMpdXml(manifestString));\n};\n\nexport { VERSION, parse, parseUTCTiming };","map":{"version":3,"sources":["/Users/quintenleysen/Documents/AZ_SINT_LUCAS/az_sint_lucas/client/node_modules/mpd-parser/dist/mpd-parser.es.js"],"names":["window$1","version","isObject","obj","merge","_len","arguments","length","objects","Array","_key","reduce","result","source","Object","keys","forEach","key","isArray","concat","values","o","map","k","range","start","end","i","push","flatten","lists","x","y","from","list","findIndexes","l","a","e","errors","INVALID_NUMBER_OF_PERIOD","DASH_EMPTY_MANIFEST","DASH_INVALID_XML","NO_BASE_URL","MISSING_SEGMENT_INFORMATION","SEGMENT_TIME_UNSPECIFIED","UNSUPPORTED_UTC_TIMING_SCHEME","commonjsGlobal","window","global","self","createCommonjsModule","fn","module","exports","urlToolkit","root","URL_REGEX","FIRST_SEGMENT_REGEX","SLASH_DOT_REGEX","SLASH_DOT_DOT_REGEX","URLToolkit","buildAbsoluteURL","baseURL","relativeURL","opts","trim","alwaysNormalize","basePartsForNormalise","parseURL","Error","path","normalizePath","buildURLFromParts","relativeParts","scheme","baseParts","netLoc","pathParts","exec","builtParts","params","query","fragment","baseURLPath","newPath","substring","lastIndexOf","url","parts","split","reverse","join","replace","resolveUrl","baseUrl","relativeUrl","test","location","href","urlTypeToSegment","_ref","_ref$baseUrl","_ref$source","_ref$range","_ref$indexRange","indexRange","segment","uri","resolvedUri","rangeStr","ranges","startRange","parseInt","endRange","byterange","offset","byteRangeToString","segmentRange","static","_static","attributes","duration","_attributes$timescale","timescale","sourceDuration","Math","ceil","dynamic","NOW","clientOffset","availabilityStartTime","_attributes$timescale2","_attributes$start","_attributes$minimumUp","minimumUpdatePeriod","_attributes$timeShift","timeShiftBufferDepth","Infinity","now","periodStartWC","periodEndWC","periodDuration","segmentCount","availableStart","floor","availableEnd","max","min","toSegments","number","index","_attributes$timescale3","periodIndex","_attributes$startNumb","startNumber","timeline","time","parseByDuration","_attributes$type","type","_attributes$timescale4","_segmentRange$type","segments","segmentsFromBase","_attributes$initializ","initialization","_attributes$indexRang","initSegment","sourceURL","segmentTimeInfo","addSegmentsToPlaylist","playlist","sidx","sidxByteRange","sidxEnd","mediaReferences","references","filter","r","referenceType","startIndex","firstOffset","reference","size","referencedSize","subsegmentDuration","endIndex","mergeDiscontiguousPlaylists","playlists","mergedPlaylists","acc","name","id","lang","_acc$name$segments","discontinuity","apply","contentProtection","discontinuityStarts","addSegmentInfoFromSidx","sidxMapping","sidxKey","sidxMatch","formatAudioPlaylist","_attributes","NAME","BANDWIDTH","bandwidth","CODECS","codecs","endList","targetDuration","mediaSequence","formatVttPlaylist","_ref2","_attributes2","organizeAudioPlaylists","mainPlaylist","formattedPlaylists","role","value","language","label","roleLabel","autoselect","default","firstLabel","organizeVttPlaylists","formatVideoPlaylist","_ref3","_attributes3","AUDIO","SUBTITLES","RESOLUTION","width","height","toM3u8","dashPlaylists","_mediaGroups","_dashPlaylists$0$attr","_dashPlaylists$0$attr2","videoOnly","_ref4","mimeType","contentType","audioOnly","_ref5","vttOnly","_ref6","videoPlaylists","audioPlaylists","vttPlaylists","master","allowCache","mediaGroups","VIDEO","audio","subs","getLiveRValue","parseByTimeline","segmentTimeline","_attributes$minimumUp2","_attributes$media","media","sIndex","S","d","repeat","segmentTime","t","count","nextS","indexOf","identifierPattern","identifierReplacement","match","identifier","format","constructTemplateUrl","parseTemplateInfo","segmentsFromTemplate","templateValues","RepresentationID","Bandwidth","mapSegment","Number","Time","SegmentURLToSegmentObject","segmentUrl","mediaRange","segmentsFromList","_attributes$segmentUr","segmentUrls","segmentUrlMap","segmentUrlObject","generateSegments","segmentInfo","segmentAttributes","segmentsFn","template","base","segmentsInfo","_segmentAttributes","_segmentAttributes$ti","toPlaylists","representations","findChildren","element","childNodes","tagName","getContent","textContent","parseDuration","str","SECONDS_IN_YEAR","SECONDS_IN_MONTH","SECONDS_IN_DAY","SECONDS_IN_HOUR","SECONDS_IN_MIN","durationRegex","_match$slice","slice","year","month","day","hour","minute","second","parseFloat","parseDate","dateRegex","Date","parse","parsers","mediaPresentationDuration","parsedValue","isNaN","DEFAULT","parseAttributes","el","parseFn","decodeB64ToUint8Array","b64Text","decodedString","atob","array","Uint8Array","charCodeAt","keySystemsMap","buildBaseUrls","referenceUrls","baseUrlElements","baseUrlElement","getSegmentInformation","adaptationSet","segmentTemplate","segmentList","s","tag","segmentBase","segmentTimelineParentNode","segmentInitializationParentNode","segmentInitialization","inheritBaseUrls","adaptationSetAttributes","adaptationSetBaseUrls","adaptationSetSegmentInfo","representation","repBaseUrlElements","repBaseUrls","representationSegmentInfo","generateKeySystemInformation","contentProtectionNodes","node","keySystem","schemeIdUri","psshNode","pssh","psshBuffer","toRepresentations","periodAttributes","periodBaseUrls","periodSegmentInfo","roleAttributes","attrs","toAdaptationSets","mpdAttributes","mpdBaseUrls","period","periodAtt","parsedPeriodId","adaptationSets","inheritAttributes","mpd","options","_options","_options$manifestUri","manifestUri","_options$NOW","_options$clientOffset","periods","stringToMpdXml","manifestString","parser","DOMParser","xml","parseFromString","documentElement","getElementsByTagName","parseUTCTimingScheme","UTCTimingNode","method","VERSION","parseUTCTiming"],"mappings":"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","sourcesContent":["/*! @name mpd-parser @version 0.8.1 @license Apache-2.0 */\nimport window$1 from 'global/window';\n\nvar version = \"0.8.1\";\n\nvar isObject = function isObject(obj) {\n  return !!obj && typeof obj === 'object';\n};\n\nvar merge = function merge() {\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  return objects.reduce(function (result, source) {\n    Object.keys(source).forEach(function (key) {\n      if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n        result[key] = result[key].concat(source[key]);\n      } else if (isObject(result[key]) && isObject(source[key])) {\n        result[key] = merge(result[key], source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }, {});\n};\nvar values = function values(o) {\n  return Object.keys(o).map(function (k) {\n    return o[k];\n  });\n};\n\nvar range = function range(start, end) {\n  var result = [];\n\n  for (var i = start; i < end; i++) {\n    result.push(i);\n  }\n\n  return result;\n};\nvar flatten = function flatten(lists) {\n  return lists.reduce(function (x, y) {\n    return x.concat(y);\n  }, []);\n};\nvar from = function from(list) {\n  if (!list.length) {\n    return [];\n  }\n\n  var result = [];\n\n  for (var i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n\n  return result;\n};\nvar findIndexes = function findIndexes(l, key) {\n  return l.reduce(function (a, e, i) {\n    if (e[key]) {\n      a.push(i);\n    }\n\n    return a;\n  }, []);\n};\n\nvar errors = {\n  INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n  DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n  DASH_INVALID_XML: 'DASH_INVALID_XML',\n  NO_BASE_URL: 'NO_BASE_URL',\n  MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n  SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n  UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n};\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar urlToolkit = createCommonjsModule(function (module, exports) {\n// see https://tools.ietf.org/html/rfc1808\n\n/* jshint ignore:start */\n(function(root) { \n/* jshint ignore:end */\n\n  var URL_REGEX = /^((?:[a-zA-Z0-9+\\-.]+:)?)(\\/\\/[^\\/?#]*)?((?:[^\\/\\?#]*\\/)*.*?)??(;.*?)?(\\?.*?)?(#.*?)?$/;\n  var FIRST_SEGMENT_REGEX = /^([^\\/?#]*)(.*)$/;\n  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/).*?(?=\\/)/g;\n\n  var URLToolkit = { // jshint ignore:line\n    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n    // E.g\n    // With opts.alwaysNormalize = false (default, spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n    // With opts.alwaysNormalize = true (not spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n    buildAbsoluteURL: function(baseURL, relativeURL, opts) {\n      opts = opts || {};\n      // remove any remaining space and CRLF\n      baseURL = baseURL.trim();\n      relativeURL = relativeURL.trim();\n      if (!relativeURL) {\n        // 2a) If the embedded URL is entirely empty, it inherits the\n        // entire base URL (i.e., is set equal to the base URL)\n        // and we are done.\n        if (!opts.alwaysNormalize) {\n          return baseURL;\n        }\n        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n        if (!basePartsForNormalise) {\n          throw new Error('Error trying to parse base URL.');\n        }\n        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);\n        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n      }\n      var relativeParts = URLToolkit.parseURL(relativeURL);\n      if (!relativeParts) {\n        throw new Error('Error trying to parse relative URL.');\n      }\n      if (relativeParts.scheme) {\n        // 2b) If the embedded URL starts with a scheme name, it is\n        // interpreted as an absolute URL and we are done.\n        if (!opts.alwaysNormalize) {\n          return relativeURL;\n        }\n        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n        return URLToolkit.buildURLFromParts(relativeParts);\n      }\n      var baseParts = URLToolkit.parseURL(baseURL);\n      if (!baseParts) {\n        throw new Error('Error trying to parse base URL.');\n      }\n      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n        baseParts.netLoc = pathParts[1];\n        baseParts.path = pathParts[2];\n      }\n      if (baseParts.netLoc && !baseParts.path) {\n        baseParts.path = '/';\n      }\n      var builtParts = {\n        // 2c) Otherwise, the embedded URL inherits the scheme of\n        // the base URL.\n        scheme: baseParts.scheme,\n        netLoc: relativeParts.netLoc,\n        path: null,\n        params: relativeParts.params,\n        query: relativeParts.query,\n        fragment: relativeParts.fragment\n      };\n      if (!relativeParts.netLoc) {\n        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n        // (if any) of the base URL.\n        builtParts.netLoc = baseParts.netLoc;\n        // 4) If the embedded URL path is preceded by a slash \"/\", the\n        // path is not relative and we skip to Step 7.\n        if (relativeParts.path[0] !== '/') {\n          if (!relativeParts.path) {\n            // 5) If the embedded URL path is empty (and not preceded by a\n            // slash), then the embedded URL inherits the base URL path\n            builtParts.path = baseParts.path;\n            // 5a) if the embedded URL's <params> is non-empty, we skip to\n            // step 7; otherwise, it inherits the <params> of the base\n            // URL (if any) and\n            if (!relativeParts.params) {\n              builtParts.params = baseParts.params;\n              // 5b) if the embedded URL's <query> is non-empty, we skip to\n              // step 7; otherwise, it inherits the <query> of the base\n              // URL (if any) and we skip to step 7.\n              if (!relativeParts.query) {\n                builtParts.query = baseParts.query;\n              }\n            }\n          } else {\n            // 6) The last segment of the base URL's path (anything\n            // following the rightmost slash \"/\", or the entire path if no\n            // slash is present) is removed and the embedded URL's path is\n            // appended in its place.\n            var baseURLPath = baseParts.path;\n            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;\n            builtParts.path = URLToolkit.normalizePath(newPath);\n          }\n        }\n      }\n      if (builtParts.path === null) {\n        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;\n      }\n      return URLToolkit.buildURLFromParts(builtParts);\n    },\n    parseURL: function(url) {\n      var parts = URL_REGEX.exec(url);\n      if (!parts) {\n        return null;\n      }\n      return {\n        scheme: parts[1] || '',\n        netLoc: parts[2] || '',\n        path: parts[3] || '',\n        params: parts[4] || '',\n        query: parts[5] || '',\n        fragment: parts[6] || ''\n      };\n    },\n    normalizePath: function(path) {\n      // The following operations are\n      // then applied, in order, to the new path:\n      // 6a) All occurrences of \"./\", where \".\" is a complete path\n      // segment, are removed.\n      // 6b) If the path ends with \".\" as a complete path segment,\n      // that \".\" is removed.\n      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n      // complete path segment not equal to \"..\", are removed.\n      // Removal of these path segments is performed iteratively,\n      // removing the leftmost matching pattern on each iteration,\n      // until no matching pattern remains.\n      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n      // complete path segment not equal to \"..\", that\n      // \"<segment>/..\" is removed.\n      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line\n      return path.split('').reverse().join('');\n    },\n    buildURLFromParts: function(parts) {\n      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;\n    }\n  };\n\n/* jshint ignore:start */\n  module.exports = URLToolkit;\n})(commonjsGlobal);\n/* jshint ignore:end */\n});\n\nvar resolveUrl = function resolveUrl(baseUrl, relativeUrl) {\n  // return early if we don't need to resolve\n  if (/^[a-z]+:/i.test(relativeUrl)) {\n    return relativeUrl;\n  } // if the base URL is relative then combine with the current location\n\n\n  if (!/\\/\\//i.test(baseUrl)) {\n    baseUrl = urlToolkit.buildAbsoluteURL(window$1.location.href, baseUrl);\n  }\n\n  return urlToolkit.buildAbsoluteURL(baseUrl, relativeUrl);\n};\n\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */\n\n/**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls,\n *   follows  RFC 2616, Clause 14.35.1\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */\n\nvar urlTypeToSegment = function urlTypeToSegment(_ref) {\n  var _ref$baseUrl = _ref.baseUrl,\n      baseUrl = _ref$baseUrl === void 0 ? '' : _ref$baseUrl,\n      _ref$source = _ref.source,\n      source = _ref$source === void 0 ? '' : _ref$source,\n      _ref$range = _ref.range,\n      range = _ref$range === void 0 ? '' : _ref$range,\n      _ref$indexRange = _ref.indexRange,\n      indexRange = _ref$indexRange === void 0 ? '' : _ref$indexRange;\n  var segment = {\n    uri: source,\n    resolvedUri: resolveUrl(baseUrl || '', source)\n  };\n\n  if (range || indexRange) {\n    var rangeStr = range ? range : indexRange;\n    var ranges = rangeStr.split('-');\n    var startRange = parseInt(ranges[0], 10);\n    var endRange = parseInt(ranges[1], 10); // byterange should be inclusive according to\n    // RFC 2616, Clause 14.35.1\n\n    segment.byterange = {\n      length: endRange - startRange + 1,\n      offset: startRange\n    };\n  }\n\n  return segment;\n};\nvar byteRangeToString = function byteRangeToString(byterange) {\n  // `endRange` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  var endRange = byterange.offset + byterange.length - 1;\n  return byterange.offset + \"-\" + endRange;\n};\n\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */\n\nvar segmentRange = {\n  /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  static: function _static(attributes) {\n    var duration = attributes.duration,\n        _attributes$timescale = attributes.timescale,\n        timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n        sourceDuration = attributes.sourceDuration;\n    return {\n      start: 0,\n      end: Math.ceil(sourceDuration / (duration / timescale))\n    };\n  },\n\n  /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  dynamic: function dynamic(attributes) {\n    var NOW = attributes.NOW,\n        clientOffset = attributes.clientOffset,\n        availabilityStartTime = attributes.availabilityStartTime,\n        _attributes$timescale2 = attributes.timescale,\n        timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,\n        duration = attributes.duration,\n        _attributes$start = attributes.start,\n        start = _attributes$start === void 0 ? 0 : _attributes$start,\n        _attributes$minimumUp = attributes.minimumUpdatePeriod,\n        minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp,\n        _attributes$timeShift = attributes.timeShiftBufferDepth,\n        timeShiftBufferDepth = _attributes$timeShift === void 0 ? Infinity : _attributes$timeShift;\n    var now = (NOW + clientOffset) / 1000;\n    var periodStartWC = availabilityStartTime + start;\n    var periodEndWC = now + minimumUpdatePeriod;\n    var periodDuration = periodEndWC - periodStartWC;\n    var segmentCount = Math.ceil(periodDuration * timescale / duration);\n    var availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n    var availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n    return {\n      start: Math.max(0, availableStart),\n      end: Math.min(segmentCount, availableEnd)\n    };\n  }\n};\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */\n\nvar toSegments = function toSegments(attributes) {\n  return function (number, index) {\n    var duration = attributes.duration,\n        _attributes$timescale3 = attributes.timescale,\n        timescale = _attributes$timescale3 === void 0 ? 1 : _attributes$timescale3,\n        periodIndex = attributes.periodIndex,\n        _attributes$startNumb = attributes.startNumber,\n        startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb;\n    return {\n      number: startNumber + number,\n      duration: duration / timescale,\n      timeline: periodIndex,\n      time: index * duration\n    };\n  };\n};\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nvar parseByDuration = function parseByDuration(attributes) {\n  var _attributes$type = attributes.type,\n      type = _attributes$type === void 0 ? 'static' : _attributes$type,\n      duration = attributes.duration,\n      _attributes$timescale4 = attributes.timescale,\n      timescale = _attributes$timescale4 === void 0 ? 1 : _attributes$timescale4,\n      sourceDuration = attributes.sourceDuration;\n\n  var _segmentRange$type = segmentRange[type](attributes),\n      start = _segmentRange$type.start,\n      end = _segmentRange$type.end;\n\n  var segments = range(start, end).map(toSegments(attributes));\n\n  if (type === 'static') {\n    var index = segments.length - 1; // final segment may be less than full segment duration\n\n    segments[index].duration = sourceDuration - duration / timescale * index;\n  }\n\n  return segments;\n};\n\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */\n\nvar segmentsFromBase = function segmentsFromBase(attributes) {\n  var baseUrl = attributes.baseUrl,\n      _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ,\n      sourceDuration = attributes.sourceDuration,\n      _attributes$timescale = attributes.timescale,\n      timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n      _attributes$indexRang = attributes.indexRange,\n      indexRange = _attributes$indexRang === void 0 ? '' : _attributes$indexRang,\n      duration = attributes.duration; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n  if (!baseUrl) {\n    throw new Error(errors.NO_BASE_URL);\n  }\n\n  var initSegment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  var segment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: baseUrl,\n    indexRange: indexRange\n  });\n  segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n  // (since SegmentBase is only for one total segment)\n\n  if (duration) {\n    var segmentTimeInfo = parseByDuration(attributes);\n\n    if (segmentTimeInfo.length) {\n      segment.duration = segmentTimeInfo[0].duration;\n      segment.timeline = segmentTimeInfo[0].timeline;\n    }\n  } else if (sourceDuration) {\n    segment.duration = sourceDuration / timescale;\n    segment.timeline = 0;\n  } // This is used for mediaSequence\n\n\n  segment.number = 0;\n  return [segment];\n};\n/**\n * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n * according to the sidx information given.\n *\n * playlist.sidx has metadadata about the sidx where-as the sidx param\n * is the parsed sidx box itself.\n *\n * @param {Object} playlist the playlist to update the sidx information for\n * @param {Object} sidx the parsed sidx box\n * @return {Object} the playlist object with the updated sidx information\n */\n\nvar addSegmentsToPlaylist = function addSegmentsToPlaylist(playlist, sidx, baseUrl) {\n  // Retain init segment information\n  var initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial master manifest parsing\n\n  var sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n  var timeline = playlist.timeline || 0;\n  var sidxByteRange = playlist.sidx.byterange;\n  var sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n  var timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n  var mediaReferences = sidx.references.filter(function (r) {\n    return r.referenceType !== 1;\n  });\n  var segments = []; // firstOffset is the offset from the end of the sidx box\n\n  var startIndex = sidxEnd + sidx.firstOffset;\n\n  for (var i = 0; i < mediaReferences.length; i++) {\n    var reference = sidx.references[i]; // size of the referenced (sub)segment\n\n    var size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n    // this will be converted to seconds when generating segments\n\n    var duration = reference.subsegmentDuration; // should be an inclusive range\n\n    var endIndex = startIndex + size - 1;\n    var indexRange = startIndex + \"-\" + endIndex;\n    var attributes = {\n      baseUrl: baseUrl,\n      timescale: timescale,\n      timeline: timeline,\n      // this is used in parseByDuration\n      periodIndex: timeline,\n      duration: duration,\n      sourceDuration: sourceDuration,\n      indexRange: indexRange\n    };\n    var segment = segmentsFromBase(attributes)[0];\n\n    if (initSegment) {\n      segment.map = initSegment;\n    }\n\n    segments.push(segment);\n    startIndex += size;\n  }\n\n  playlist.segments = segments;\n  return playlist;\n};\n\nvar mergeDiscontiguousPlaylists = function mergeDiscontiguousPlaylists(playlists) {\n  var mergedPlaylists = values(playlists.reduce(function (acc, playlist) {\n    // assuming playlist IDs are the same across periods\n    // TODO: handle multiperiod where representation sets are not the same\n    // across periods\n    var name = playlist.attributes.id + (playlist.attributes.lang || ''); // Periods after first\n\n    if (acc[name]) {\n      var _acc$name$segments;\n\n      // first segment of subsequent periods signal a discontinuity\n      if (playlist.segments[0]) {\n        playlist.segments[0].discontinuity = true;\n      }\n\n      (_acc$name$segments = acc[name].segments).push.apply(_acc$name$segments, playlist.segments); // bubble up contentProtection, this assumes all DRM content\n      // has the same contentProtection\n\n\n      if (playlist.attributes.contentProtection) {\n        acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n      }\n    } else {\n      // first Period\n      acc[name] = playlist;\n    }\n\n    return acc;\n  }, {}));\n  return mergedPlaylists.map(function (playlist) {\n    playlist.discontinuityStarts = findIndexes(playlist.segments, 'discontinuity');\n    return playlist;\n  });\n};\n\nvar addSegmentInfoFromSidx = function addSegmentInfoFromSidx(playlists, sidxMapping) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  if (!Object.keys(sidxMapping).length) {\n    return playlists;\n  }\n\n  for (var i in playlists) {\n    var playlist = playlists[i];\n\n    if (!playlist.sidx) {\n      continue;\n    }\n\n    var sidxKey = playlist.sidx.uri + '-' + byteRangeToString(playlist.sidx.byterange);\n    var sidxMatch = sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n\n    if (playlist.sidx && sidxMatch) {\n      addSegmentsToPlaylist(playlist, sidxMatch, playlist.sidx.resolvedUri);\n    }\n  }\n\n  return playlists;\n};\n\nvar formatAudioPlaylist = function formatAudioPlaylist(_ref) {\n  var _attributes;\n\n  var attributes = _ref.attributes,\n      segments = _ref.segments,\n      sidx = _ref.sidx;\n  var playlist = {\n    attributes: (_attributes = {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      CODECS: attributes.codecs\n    }, _attributes['PROGRAM-ID'] = 1, _attributes),\n    uri: '',\n    endList: (attributes.type || 'static') === 'static',\n    timeline: attributes.periodIndex,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    segments: segments,\n    mediaSequence: segments.length ? segments[0].number : 1\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  return playlist;\n};\nvar formatVttPlaylist = function formatVttPlaylist(_ref2) {\n  var _attributes2;\n\n  var attributes = _ref2.attributes,\n      segments = _ref2.segments;\n\n  if (typeof segments === 'undefined') {\n    // vtt tracks may use single file in BaseURL\n    segments = [{\n      uri: attributes.baseUrl,\n      timeline: attributes.periodIndex,\n      resolvedUri: attributes.baseUrl || '',\n      duration: attributes.sourceDuration,\n      number: 0\n    }]; // targetDuration should be the same duration as the only segment\n\n    attributes.duration = attributes.sourceDuration;\n  }\n\n  return {\n    attributes: (_attributes2 = {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth\n    }, _attributes2['PROGRAM-ID'] = 1, _attributes2),\n    uri: '',\n    endList: (attributes.type || 'static') === 'static',\n    timeline: attributes.periodIndex,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    segments: segments,\n    mediaSequence: segments.length ? segments[0].number : 1\n  };\n};\nvar organizeAudioPlaylists = function organizeAudioPlaylists(playlists, sidxMapping) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  var mainPlaylist;\n  var formattedPlaylists = playlists.reduce(function (a, playlist) {\n    var role = playlist.attributes.role && playlist.attributes.role.value || '';\n    var language = playlist.attributes.lang || '';\n    var label = 'main';\n\n    if (language) {\n      var roleLabel = role ? \" (\" + role + \")\" : '';\n      label = \"\" + playlist.attributes.lang + roleLabel;\n    } // skip if we already have the highest quality audio for a language\n\n\n    if (a[label] && a[label].playlists[0].attributes.BANDWIDTH > playlist.attributes.bandwidth) {\n      return a;\n    }\n\n    a[label] = {\n      language: language,\n      autoselect: true,\n      default: role === 'main',\n      playlists: addSegmentInfoFromSidx([formatAudioPlaylist(playlist)], sidxMapping),\n      uri: ''\n    };\n\n    if (typeof mainPlaylist === 'undefined' && role === 'main') {\n      mainPlaylist = playlist;\n      mainPlaylist.default = true;\n    }\n\n    return a;\n  }, {}); // if no playlists have role \"main\", mark the first as main\n\n  if (!mainPlaylist) {\n    var firstLabel = Object.keys(formattedPlaylists)[0];\n    formattedPlaylists[firstLabel].default = true;\n  }\n\n  return formattedPlaylists;\n};\nvar organizeVttPlaylists = function organizeVttPlaylists(playlists, sidxMapping) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  return playlists.reduce(function (a, playlist) {\n    var label = playlist.attributes.lang || 'text'; // skip if we already have subtitles\n\n    if (a[label]) {\n      return a;\n    }\n\n    a[label] = {\n      language: label,\n      default: false,\n      autoselect: false,\n      playlists: addSegmentInfoFromSidx([formatVttPlaylist(playlist)], sidxMapping),\n      uri: ''\n    };\n    return a;\n  }, {});\n};\nvar formatVideoPlaylist = function formatVideoPlaylist(_ref3) {\n  var _attributes3;\n\n  var attributes = _ref3.attributes,\n      segments = _ref3.segments,\n      sidx = _ref3.sidx;\n  var playlist = {\n    attributes: (_attributes3 = {\n      NAME: attributes.id,\n      AUDIO: 'audio',\n      SUBTITLES: 'subs',\n      RESOLUTION: {\n        width: attributes.width,\n        height: attributes.height\n      },\n      CODECS: attributes.codecs,\n      BANDWIDTH: attributes.bandwidth\n    }, _attributes3['PROGRAM-ID'] = 1, _attributes3),\n    uri: '',\n    endList: (attributes.type || 'static') === 'static',\n    timeline: attributes.periodIndex,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    segments: segments,\n    mediaSequence: segments.length ? segments[0].number : 1\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  return playlist;\n};\nvar toM3u8 = function toM3u8(dashPlaylists, sidxMapping) {\n  var _mediaGroups;\n\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  if (!dashPlaylists.length) {\n    return {};\n  } // grab all master attributes\n\n\n  var _dashPlaylists$0$attr = dashPlaylists[0].attributes,\n      duration = _dashPlaylists$0$attr.sourceDuration,\n      _dashPlaylists$0$attr2 = _dashPlaylists$0$attr.minimumUpdatePeriod,\n      minimumUpdatePeriod = _dashPlaylists$0$attr2 === void 0 ? 0 : _dashPlaylists$0$attr2;\n\n  var videoOnly = function videoOnly(_ref4) {\n    var attributes = _ref4.attributes;\n    return attributes.mimeType === 'video/mp4' || attributes.contentType === 'video';\n  };\n\n  var audioOnly = function audioOnly(_ref5) {\n    var attributes = _ref5.attributes;\n    return attributes.mimeType === 'audio/mp4' || attributes.contentType === 'audio';\n  };\n\n  var vttOnly = function vttOnly(_ref6) {\n    var attributes = _ref6.attributes;\n    return attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n  };\n\n  var videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n  var audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n  var vttPlaylists = dashPlaylists.filter(vttOnly);\n  var master = {\n    allowCache: true,\n    discontinuityStarts: [],\n    segments: [],\n    endList: true,\n    mediaGroups: (_mediaGroups = {\n      AUDIO: {},\n      VIDEO: {}\n    }, _mediaGroups['CLOSED-CAPTIONS'] = {}, _mediaGroups.SUBTITLES = {}, _mediaGroups),\n    uri: '',\n    duration: duration,\n    playlists: addSegmentInfoFromSidx(videoPlaylists, sidxMapping),\n    minimumUpdatePeriod: minimumUpdatePeriod * 1000\n  };\n\n  if (audioPlaylists.length) {\n    master.mediaGroups.AUDIO.audio = organizeAudioPlaylists(audioPlaylists, sidxMapping);\n  }\n\n  if (vttPlaylists.length) {\n    master.mediaGroups.SUBTITLES.subs = organizeVttPlaylists(vttPlaylists, sidxMapping);\n  }\n\n  return master;\n};\n\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */\nvar getLiveRValue = function getLiveRValue(attributes, time, duration) {\n  var NOW = attributes.NOW,\n      clientOffset = attributes.clientOffset,\n      availabilityStartTime = attributes.availabilityStartTime,\n      _attributes$timescale = attributes.timescale,\n      timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n      _attributes$start = attributes.start,\n      start = _attributes$start === void 0 ? 0 : _attributes$start,\n      _attributes$minimumUp = attributes.minimumUpdatePeriod,\n      minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp;\n  var now = (NOW + clientOffset) / 1000;\n  var periodStartWC = availabilityStartTime + start;\n  var periodEndWC = now + minimumUpdatePeriod;\n  var periodDuration = periodEndWC - periodStartWC;\n  return Math.ceil((periodDuration * timescale - time) / duration);\n};\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nvar parseByTimeline = function parseByTimeline(attributes, segmentTimeline) {\n  var _attributes$type = attributes.type,\n      type = _attributes$type === void 0 ? 'static' : _attributes$type,\n      _attributes$minimumUp2 = attributes.minimumUpdatePeriod,\n      minimumUpdatePeriod = _attributes$minimumUp2 === void 0 ? 0 : _attributes$minimumUp2,\n      _attributes$media = attributes.media,\n      media = _attributes$media === void 0 ? '' : _attributes$media,\n      sourceDuration = attributes.sourceDuration,\n      _attributes$timescale2 = attributes.timescale,\n      timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,\n      _attributes$startNumb = attributes.startNumber,\n      startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb,\n      timeline = attributes.periodIndex;\n  var segments = [];\n  var time = -1;\n\n  for (var sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n    var S = segmentTimeline[sIndex];\n    var duration = S.d;\n    var repeat = S.r || 0;\n    var segmentTime = S.t || 0;\n\n    if (time < 0) {\n      // first segment\n      time = segmentTime;\n    }\n\n    if (segmentTime && segmentTime > time) {\n      // discontinuity\n      // TODO: How to handle this type of discontinuity\n      // timeline++ here would treat it like HLS discontuity and content would\n      // get appended without gap\n      // E.G.\n      //  <S t=\"0\" d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S t=\"5\" d=\"1\" />\n      // would have $Time$ values of [0, 1, 2, 5]\n      // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n      // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n      // does the value of sourceDuration consider this when calculating arbitrary\n      // negative @r repeat value?\n      // E.G. Same elements as above with this added at the end\n      //  <S d=\"1\" r=\"-1\" />\n      //  with a sourceDuration of 10\n      // Would the 2 gaps be included in the time duration calculations resulting in\n      // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n      // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n      time = segmentTime;\n    }\n\n    var count = void 0;\n\n    if (repeat < 0) {\n      var nextS = sIndex + 1;\n\n      if (nextS === segmentTimeline.length) {\n        // last segment\n        if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n          count = getLiveRValue(attributes, time, duration);\n        } else {\n          // TODO: This may be incorrect depending on conclusion of TODO above\n          count = (sourceDuration * timescale - time) / duration;\n        }\n      } else {\n        count = (segmentTimeline[nextS].t - time) / duration;\n      }\n    } else {\n      count = repeat + 1;\n    }\n\n    var end = startNumber + segments.length + count;\n    var number = startNumber + segments.length;\n\n    while (number < end) {\n      segments.push({\n        number: number,\n        duration: duration / timescale,\n        time: time,\n        timeline: timeline\n      });\n      time += duration;\n      number++;\n    }\n  }\n\n  return segments;\n};\n\nvar identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */\n\n/**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */\n\nvar identifierReplacement = function identifierReplacement(values) {\n  return function (match, identifier, format, width) {\n    if (match === '$$') {\n      // escape sequence\n      return '$';\n    }\n\n    if (typeof values[identifier] === 'undefined') {\n      return match;\n    }\n\n    var value = '' + values[identifier];\n\n    if (identifier === 'RepresentationID') {\n      // Format tag shall not be present with RepresentationID\n      return value;\n    }\n\n    if (!format) {\n      width = 1;\n    } else {\n      width = parseInt(width, 10);\n    }\n\n    if (value.length >= width) {\n      return value;\n    }\n\n    return \"\" + new Array(width - value.length + 1).join('0') + value;\n  };\n};\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */\n\nvar constructTemplateUrl = function constructTemplateUrl(url, values) {\n  return url.replace(identifierPattern, identifierReplacement(values));\n};\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nvar parseTemplateInfo = function parseTemplateInfo(attributes, segmentTimeline) {\n  if (!attributes.duration && !segmentTimeline) {\n    // if neither @duration or SegmentTimeline are present, then there shall be exactly\n    // one media segment\n    return [{\n      number: attributes.startNumber || 1,\n      duration: attributes.sourceDuration,\n      time: 0,\n      timeline: attributes.periodIndex\n    }];\n  }\n\n  if (attributes.duration) {\n    return parseByDuration(attributes);\n  }\n\n  return parseByTimeline(attributes, segmentTimeline);\n};\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */\n\nvar segmentsFromTemplate = function segmentsFromTemplate(attributes, segmentTimeline) {\n  var templateValues = {\n    RepresentationID: attributes.id,\n    Bandwidth: attributes.bandwidth || 0\n  };\n  var _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {\n    sourceURL: '',\n    range: ''\n  } : _attributes$initializ;\n  var mapSegment = urlTypeToSegment({\n    baseUrl: attributes.baseUrl,\n    source: constructTemplateUrl(initialization.sourceURL, templateValues),\n    range: initialization.range\n  });\n  var segments = parseTemplateInfo(attributes, segmentTimeline);\n  return segments.map(function (segment) {\n    templateValues.Number = segment.number;\n    templateValues.Time = segment.time;\n    var uri = constructTemplateUrl(attributes.media || '', templateValues);\n    return {\n      uri: uri,\n      timeline: segment.timeline,\n      duration: segment.duration,\n      resolvedUri: resolveUrl(attributes.baseUrl || '', uri),\n      map: mapSegment,\n      number: segment.number\n    };\n  });\n};\n\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */\n\nvar SegmentURLToSegmentObject = function SegmentURLToSegmentObject(attributes, segmentUrl) {\n  var baseUrl = attributes.baseUrl,\n      _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ;\n  var initSegment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  var segment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: segmentUrl.media,\n    range: segmentUrl.mediaRange\n  });\n  segment.map = initSegment;\n  return segment;\n};\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */\n\n\nvar segmentsFromList = function segmentsFromList(attributes, segmentTimeline) {\n  var duration = attributes.duration,\n      _attributes$segmentUr = attributes.segmentUrls,\n      segmentUrls = _attributes$segmentUr === void 0 ? [] : _attributes$segmentUr; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n  // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n  if (!duration && !segmentTimeline || duration && segmentTimeline) {\n    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n  }\n\n  var segmentUrlMap = segmentUrls.map(function (segmentUrlObject) {\n    return SegmentURLToSegmentObject(attributes, segmentUrlObject);\n  });\n  var segmentTimeInfo;\n\n  if (duration) {\n    segmentTimeInfo = parseByDuration(attributes);\n  }\n\n  if (segmentTimeline) {\n    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n  }\n\n  var segments = segmentTimeInfo.map(function (segmentTime, index) {\n    if (segmentUrlMap[index]) {\n      var segment = segmentUrlMap[index];\n      segment.timeline = segmentTime.timeline;\n      segment.duration = segmentTime.duration;\n      segment.number = segmentTime.number;\n      return segment;\n    } // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n\n  }).filter(function (segment) {\n    return segment;\n  });\n  return segments;\n};\n\nvar generateSegments = function generateSegments(_ref) {\n  var attributes = _ref.attributes,\n      segmentInfo = _ref.segmentInfo;\n  var segmentAttributes;\n  var segmentsFn;\n\n  if (segmentInfo.template) {\n    segmentsFn = segmentsFromTemplate;\n    segmentAttributes = merge(attributes, segmentInfo.template);\n  } else if (segmentInfo.base) {\n    segmentsFn = segmentsFromBase;\n    segmentAttributes = merge(attributes, segmentInfo.base);\n  } else if (segmentInfo.list) {\n    segmentsFn = segmentsFromList;\n    segmentAttributes = merge(attributes, segmentInfo.list);\n  }\n\n  var segmentsInfo = {\n    attributes: attributes\n  };\n\n  if (!segmentsFn) {\n    return segmentsInfo;\n  }\n\n  var segments = segmentsFn(segmentAttributes, segmentInfo.timeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n  // must be in seconds. Since we've generated the segment list, we no longer need\n  // @duration to be in @timescale units, so we can convert it here.\n\n  if (segmentAttributes.duration) {\n    var _segmentAttributes = segmentAttributes,\n        duration = _segmentAttributes.duration,\n        _segmentAttributes$ti = _segmentAttributes.timescale,\n        timescale = _segmentAttributes$ti === void 0 ? 1 : _segmentAttributes$ti;\n    segmentAttributes.duration = duration / timescale;\n  } else if (segments.length) {\n    // if there is no @duration attribute, use the largest segment duration as\n    // as target duration\n    segmentAttributes.duration = segments.reduce(function (max, segment) {\n      return Math.max(max, Math.ceil(segment.duration));\n    }, 0);\n  } else {\n    segmentAttributes.duration = 0;\n  }\n\n  segmentsInfo.attributes = segmentAttributes;\n  segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n  if (segmentInfo.base && segmentAttributes.indexRange) {\n    segmentsInfo.sidx = segments[0];\n    segmentsInfo.segments = [];\n  }\n\n  return segmentsInfo;\n};\nvar toPlaylists = function toPlaylists(representations) {\n  return representations.map(generateSegments);\n};\n\nvar findChildren = function findChildren(element, name) {\n  return from(element.childNodes).filter(function (_ref) {\n    var tagName = _ref.tagName;\n    return tagName === name;\n  });\n};\nvar getContent = function getContent(element) {\n  return element.textContent.trim();\n};\n\nvar parseDuration = function parseDuration(str) {\n  var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n  var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n  var SECONDS_IN_DAY = 24 * 60 * 60;\n  var SECONDS_IN_HOUR = 60 * 60;\n  var SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n  var durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n  var match = durationRegex.exec(str);\n\n  if (!match) {\n    return 0;\n  }\n\n  var _match$slice = match.slice(1),\n      year = _match$slice[0],\n      month = _match$slice[1],\n      day = _match$slice[2],\n      hour = _match$slice[3],\n      minute = _match$slice[4],\n      second = _match$slice[5];\n\n  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\nvar parseDate = function parseDate(str) {\n  // Date format without timezone according to ISO 8601\n  // YYY-MM-DDThh:mm:ss.ssssss\n  var dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n  // expressed by ending with 'Z'\n\n  if (dateRegex.test(str)) {\n    str += 'Z';\n  }\n\n  return Date.parse(str);\n};\n\nvar parsers = {\n  /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  mediaPresentationDuration: function mediaPresentationDuration(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */\n  availabilityStartTime: function availabilityStartTime(value) {\n    return parseDate(value) / 1000;\n  },\n\n  /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  minimumUpdatePeriod: function minimumUpdatePeriod(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  timeShiftBufferDepth: function timeShiftBufferDepth(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  start: function start(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */\n  width: function width(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */\n  height: function height(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */\n  bandwidth: function bandwidth(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  startNumber: function startNumber(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The aprsed timescale\n   */\n  timescale: function timescale(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  duration: function duration(value) {\n    var parsedValue = parseInt(value, 10);\n\n    if (isNaN(parsedValue)) {\n      return parseDuration(value);\n    }\n\n    return parsedValue;\n  },\n\n  /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  d: function d(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */\n  t: function t(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  r: function r(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */\n  DEFAULT: function DEFAULT(value) {\n    return value;\n  }\n};\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */\n\nvar parseAttributes = function parseAttributes(el) {\n  if (!(el && el.attributes)) {\n    return {};\n  }\n\n  return from(el.attributes).reduce(function (a, e) {\n    var parseFn = parsers[e.name] || parsers.DEFAULT;\n    a[e.name] = parseFn(e.value);\n    return a;\n  }, {});\n};\n\nfunction decodeB64ToUint8Array(b64Text) {\n  var decodedString = window$1.atob(b64Text);\n  var array = new Uint8Array(decodedString.length);\n\n  for (var i = 0; i < decodedString.length; i++) {\n    array[i] = decodedString.charCodeAt(i);\n  }\n\n  return array;\n}\n\nvar keySystemsMap = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\n};\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {string[]} referenceUrls\n *        List of reference urls to resolve to\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {string[]}\n *         List of resolved urls\n */\n\nvar buildBaseUrls = function buildBaseUrls(referenceUrls, baseUrlElements) {\n  if (!baseUrlElements.length) {\n    return referenceUrls;\n  }\n\n  return flatten(referenceUrls.map(function (reference) {\n    return baseUrlElements.map(function (baseUrlElement) {\n      return resolveUrl(reference, getContent(baseUrlElement));\n    });\n  }));\n};\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} timeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */\n\n/**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */\n\nvar getSegmentInformation = function getSegmentInformation(adaptationSet) {\n  var segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n  var segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n  var segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(function (s) {\n    return merge({\n      tag: 'SegmentURL'\n    }, parseAttributes(s));\n  });\n  var segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n  var segmentTimelineParentNode = segmentList || segmentTemplate;\n  var segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n  var segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n  var segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n  // @initialization and an <Initialization> node.  @initialization can be templated,\n  // while the node can have a url and range specified.  If the <SegmentTemplate> has\n  // both @initialization and an <Initialization> subelement we opt to override with\n  // the node, as this interaction is not defined in the spec.\n\n  var template = segmentTemplate && parseAttributes(segmentTemplate);\n\n  if (template && segmentInitialization) {\n    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n  } else if (template && template.initialization) {\n    // If it is @initialization we convert it to an object since this is the format that\n    // later functions will rely on for the initialization segment.  This is only valid\n    // for <SegmentTemplate>\n    template.initialization = {\n      sourceURL: template.initialization\n    };\n  }\n\n  var segmentInfo = {\n    template: template,\n    timeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(function (s) {\n      return parseAttributes(s);\n    }),\n    list: segmentList && merge(parseAttributes(segmentList), {\n      segmentUrls: segmentUrls,\n      initialization: parseAttributes(segmentInitialization)\n    }),\n    base: segmentBase && merge(parseAttributes(segmentBase), {\n      initialization: parseAttributes(segmentInitialization)\n    })\n  };\n  Object.keys(segmentInfo).forEach(function (key) {\n    if (!segmentInfo[key]) {\n      delete segmentInfo[key];\n    }\n  });\n  return segmentInfo;\n};\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */\n\n/**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {string[]} adaptationSetBaseUrls\n *        Contains list of resolved base urls inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */\n\nvar inheritBaseUrls = function inheritBaseUrls(adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) {\n  return function (representation) {\n    var repBaseUrlElements = findChildren(representation, 'BaseURL');\n    var repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n    var attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n    var representationSegmentInfo = getSegmentInformation(representation);\n    return repBaseUrls.map(function (baseUrl) {\n      return {\n        segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n        attributes: merge(attributes, {\n          baseUrl: baseUrl\n        })\n      };\n    });\n  };\n};\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */\n\nvar generateKeySystemInformation = function generateKeySystemInformation(contentProtectionNodes) {\n  return contentProtectionNodes.reduce(function (acc, node) {\n    var attributes = parseAttributes(node);\n    var keySystem = keySystemsMap[attributes.schemeIdUri];\n\n    if (keySystem) {\n      acc[keySystem] = {\n        attributes: attributes\n      };\n      var psshNode = findChildren(node, 'cenc:pssh')[0];\n\n      if (psshNode) {\n        var pssh = getContent(psshNode);\n        var psshBuffer = pssh && decodeB64ToUint8Array(pssh);\n        acc[keySystem].pssh = psshBuffer;\n      }\n    }\n\n    return acc;\n  }, {});\n};\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {string[]} periodBaseUrls\n *        Contains list of resolved base urls inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */\n\n\nvar toRepresentations = function toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo) {\n  return function (adaptationSet) {\n    var adaptationSetAttributes = parseAttributes(adaptationSet);\n    var adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n    var role = findChildren(adaptationSet, 'Role')[0];\n    var roleAttributes = {\n      role: parseAttributes(role)\n    };\n    var attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n    var contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n\n    if (Object.keys(contentProtection).length) {\n      attrs = merge(attrs, {\n        contentProtection: contentProtection\n      });\n    }\n\n    var segmentInfo = getSegmentInformation(adaptationSet);\n    var representations = findChildren(adaptationSet, 'Representation');\n    var adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n    return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n  };\n};\n/**\n * Maps an Period node to a list of Representation inforamtion objects for all\n * AdaptationSet nodes contained within the Period\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {Node} period\n *        Period node from the mpd\n * @param {number} periodIndex\n *        Index of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n * @param {string[]} mpdBaseUrls\n *        Contains list of resolved base urls inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */\n\nvar toAdaptationSets = function toAdaptationSets(mpdAttributes, mpdBaseUrls) {\n  return function (period, index) {\n    var periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period, 'BaseURL'));\n    var periodAtt = parseAttributes(period);\n    var parsedPeriodId = parseInt(periodAtt.id, 10); // fallback to mapping index if Period@id is not a number\n\n    var periodIndex = window$1.isNaN(parsedPeriodId) ? index : parsedPeriodId;\n    var periodAttributes = merge(mpdAttributes, {\n      periodIndex: periodIndex\n    });\n    var adaptationSets = findChildren(period, 'AdaptationSet');\n    var periodSegmentInfo = getSegmentInformation(period);\n    return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n  };\n};\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */\n\nvar inheritAttributes = function inheritAttributes(mpd, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$manifestUri = _options.manifestUri,\n      manifestUri = _options$manifestUri === void 0 ? '' : _options$manifestUri,\n      _options$NOW = _options.NOW,\n      NOW = _options$NOW === void 0 ? Date.now() : _options$NOW,\n      _options$clientOffset = _options.clientOffset,\n      clientOffset = _options$clientOffset === void 0 ? 0 : _options$clientOffset;\n  var periods = findChildren(mpd, 'Period');\n\n  if (!periods.length) {\n    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n  }\n\n  var mpdAttributes = parseAttributes(mpd);\n  var mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, 'BaseURL'));\n  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n  mpdAttributes.NOW = NOW;\n  mpdAttributes.clientOffset = clientOffset;\n  return flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)));\n};\n\nvar stringToMpdXml = function stringToMpdXml(manifestString) {\n  if (manifestString === '') {\n    throw new Error(errors.DASH_EMPTY_MANIFEST);\n  }\n\n  var parser = new window$1.DOMParser();\n  var xml = parser.parseFromString(manifestString, 'application/xml');\n  var mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n\n  if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n    throw new Error(errors.DASH_INVALID_XML);\n  }\n\n  return mpd;\n};\n\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\nvar parseUTCTimingScheme = function parseUTCTimingScheme(mpd) {\n  var UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n\n  if (!UTCTimingNode) {\n    return null;\n  }\n\n  var attributes = parseAttributes(UTCTimingNode);\n\n  switch (attributes.schemeIdUri) {\n    case 'urn:mpeg:dash:utc:http-head:2014':\n    case 'urn:mpeg:dash:utc:http-head:2012':\n      attributes.method = 'HEAD';\n      break;\n\n    case 'urn:mpeg:dash:utc:http-xsdate:2014':\n    case 'urn:mpeg:dash:utc:http-iso:2014':\n    case 'urn:mpeg:dash:utc:http-xsdate:2012':\n    case 'urn:mpeg:dash:utc:http-iso:2012':\n      attributes.method = 'GET';\n      break;\n\n    case 'urn:mpeg:dash:utc:direct:2014':\n    case 'urn:mpeg:dash:utc:direct:2012':\n      attributes.method = 'DIRECT';\n      attributes.value = Date.parse(attributes.value);\n      break;\n\n    case 'urn:mpeg:dash:utc:http-ntp:2014':\n    case 'urn:mpeg:dash:utc:ntp:2014':\n    case 'urn:mpeg:dash:utc:sntp:2014':\n    default:\n      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n  }\n\n  return attributes;\n};\n\nvar VERSION = version;\nvar parse = function parse(manifestString, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return toM3u8(toPlaylists(inheritAttributes(stringToMpdXml(manifestString), options)), options.sidxMapping);\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\nvar parseUTCTiming = function parseUTCTiming(manifestString) {\n  return parseUTCTimingScheme(stringToMpdXml(manifestString));\n};\n\nexport { VERSION, parse, parseUTCTiming };\n"]},"metadata":{},"sourceType":"module"}